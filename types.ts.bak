export type GeneratorOptions = {
  stop?: string | string[];
  maxTokens?: number;
  //   choices?: string[];
};
export type LMGenerator<T extends string> = {
  _tag: "LMGenerator";
  name: T;
  options: GeneratorOptions;
};

type SelectorOptions<S extends string> = {
  choices: S[];
};
export type LMSelector<T extends string, S extends string> = {
  _tag: "LMSelector";
  name: T;
  options: SelectorOptions<S>;
};

export function gen<T extends string>(
  name: T,
  options?: GeneratorOptions
): LMGenerator<T>;
export function gen(options?: GeneratorOptions): LMGenerator<never>;
export function gen(...args: any) {
  let argsTyped = args as [string, GeneratorOptions] | [GeneratorOptions];
  let nameOrOptions = argsTyped[0];
  let options = argsTyped[1];
  if (typeof nameOrOptions === "string") {
    return { _tag: "LMGenerator", name: nameOrOptions, options: options || {} };
  } else {
    return {
      _tag: "LMGenerator",
      name: "default",
      options: nameOrOptions || {},
    };
  }
}

export type Interpolations<T extends string, S extends string> =
  | LMGenerator<T>
  | string
  | number
  | LMSelector<T, S>;

export type MetaInfo = {};

export type StateFn<T> = {
  isMutable: boolean;
  mutable(): StateFn<Record<string, string | undefined>>;
  clone(): StateFn<T>;
  captured: T;
  text: string;
  metaInfos: MetaInfo[];
  gen<U extends string>(
    name: U,
    options?: GeneratorOptions
  ): Promise<
    StateFn<{
      [K in U | keyof T]: K extends U
        ? string
        : K extends keyof T
        ? T[K]
        : never;
    }>
  >;
  gen(options?: GeneratorOptions): Promise<StateFn<T>>;
  select<U extends string, S extends string>(
    name: U,
    options: SelectorOptions<S>
  ): Promise<
    StateFn<{
      [K in U | keyof T]: K extends U ? S : K extends keyof T ? T[K] : never;
    }>
  >;
  select(options: SelectorOptions<string>): Promise<StateFn<T>>;
  system: StateFn<T>;
  user: StateFn<T>;
  assistant: StateFn<T>;
} & (<U extends string = never, S extends string = string>(
  strings: TemplateStringsArray,
  ...keys: Interpolations<U, S>[]
) => Promise<
  StateFn<{
    [K in U | keyof T]: K extends U ? S : K extends keyof T ? T[K] : never;
  }>
>);

export type InitializedModel = StateFn<{}>;
